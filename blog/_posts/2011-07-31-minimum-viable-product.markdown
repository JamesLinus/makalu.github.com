---
layout: post
title: Minimum Viable Products
author: Matt Henderson
teaser: Our latest post is about minimum viable products.
excerpt: Our aim for version 1.0 of RaceSplitter was to deliver a “minimum viable product”. This article discusses what that means to us.
---

Early in 2011, we at Makalu released our first product — “RaceSplitter,” an application for the iPhone that changes how organizers of sporting events time their races. Our aim for version 1.0 was to deliver a “minimum viable product”. This article discusses what that means to us.

#### Minimal product does not mean minimal implementation

Any organization that sets out to bring a product to market must decide what to build, and on that point it’s common to hear people speak of a “minimum viable product”. For Makalu, the minimum viable product contains the minimal functionality to deliver the core of the product’s value proposition. 

Perhaps in a rush to market, or in the interest of minimizing costs, many organizations take the definition one step further, to include the minimum *implementation* of the minimum functionality. We believe this is a mistake, and is short-sighted, given the criticality of the user experience in the success of any product — and particularly a version 1.0.

#### The effort difference between a minimal implementation, and a minimal product can be considerable

After 200 man-hours of effort, we had a version of RaceSplitter which was minimally functional, in that it implemented all of the features we considered core to the product — you could create and configure a race, you could time a race, and you could export results.

But it wasn’t until we’d invested an additional *400 hours* that we felt we had a minimum *viable* product — i.e. a product that delivered the core functionality, and within an experience so delightful that the users would what to tell others about it.

That’s right — fully *two thirds* of the overall development cost of the product went into improving the user experience. 

Here’s a number of examples:

1. **Reducing fundamental interface complexity.** The user interaction model went through three fundamental revisions. Each revision reduced one complete level of hierarchy. The result was an interface providing access to the essential features, with far fewed clicks. Identifing potential reductions of hierarchy is as important, as it is difficult, and requires a conscious effort not to get stuck in the current interface paradigm.

2. **Making the user think less.** The interaction of the timing model — i.e. how the user records the time when a racer passes by — went through several iterations until one was found that supported three modes of timing simultaneously: (1) single racer timing, (2) group timing (giving the same time to multiple racers), and (3) sub-group timing (giving the same time to a subset of a selected group of racers). By supporting all timing scenarios in a single interaction model, we avoid one user choice: “Which mode should I select?” That's a lot of effort to reduce a single decision, but in the heat of a race, that can make the difference between successful and failed use of the product.

3. **Reducing interface friction.** Through real-world use of the product, we continually noted any time when we (or users we observed) momentarily paused when interacting with the app, and then made efforts to eliminate these UI friction points. For example, when changing a race from one start mode to another — e.g. from *interval* start to *mass* start — we inform the user what effect that’s going to have on the ordering of any racers already existing in the start list (giving them the chance to cancel the change). This contextual feedback eliminated that momentary, "Uh oh, how's this going to affect things I've already done?" friction.

#### Iterate with high-fidelity prototypes.

We found that these kinds of user experience refinements are best achieved through an iterative process of testing high-fidelity (working) prototypes of the application, and diligently seeking to identify points of friction. 

You can identify friction by watching someone use the product for the first time, without a manual. When you ask them to create and run a race, and observe a smooth tap-tap-tap-tap-tap-done, you know you’re on the right path. But when you see tap-tap...hmmm...tap...oops...tap — you know further thinking and refinements are needed.

#### Costly, but worth it.

This process of iterating with working prototypes is obviously a lot more costly than, say, depending on static mockups. On the other hand, we’re convinced that in the long term, it’s the best path to creating successful products — meaning, products that *succeed* in the market.

In the case of RaceSplitter, our users *loved* the product. In fact, due to the enthusiasm of a single early adopter in Norway, we’ve ended up selling nearly as many copies in that one small country as we have in the United States. 

Although there are many areas in which RaceSplitter can (and will) be improved, the most frequent feedback we've received has been along the lines of, “Wow — it’s so easy to use! With no instruction at all, my friend timed the entire event, edited a couple mis-entries, and published the results online.”

#### It’s your choice.

Shipping the minimal implementation of the minimum viable product increases the chance that your first users will think, “Nice idea. I’ll try to remember to check back someday.”

Perfect execution of the minimal viable product, on the other hand, increases the chances of turning your early adopters into the organic, social marketing force that can be critical to the success of so many 1.0 products.
